## 数据库（MySQL）

**数据三范式**

> 1NF：【联系人】（姓名，性别，电话），一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF
>
> 2NF：有主键，保证完全依赖。eg:订单明细表【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName），Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID，不符合2NF
>
> 3NF：无传递依赖(非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况)

**什么是存储过程？有哪些优缺点**

> 一组为了完成特定功能的SQL 语句集，经编译后存储在数据库。中用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。优点：减少重复劳动、执行速度更快、减少网络通信量。缺点：场景单一，移植性差。
>

**什么是触发器？**https://zhuanlan.zhihu.com/p/60234138

> 触发器是一个特殊的存储过程，不同的是存储过程要CALL来调用，而触发器不需要使用CALL ，也不需要手工启动，只要当一个预定义的事件发生的时候，就会被MYSQL自动调用。



**数据库事务**  https://www.zhihu.com/question/30272728

> 四大特性：ACID（Atomicity、Isolation、Durability、Consistency）
>
> 原子性如何保证？全部做完才提交，中间有失败直接rollback到事务开始之前的状态，通过redo和undo日志实现
>
> redo: 成功提交但未写入硬盘；undo：执行了一部分但尚未提交
>
> 隔离性如何保证？对可能被其他事务访问的资源加锁，事务提交后再释放。
>
> 持久性：已提交的事务序列化到硬盘。未提交的事务回滚。
>
> 最基本的是一致性，前面三个都是为了保证它而存在的
>

**事务的隔离级别**

> 并发事务产生的问题：
>
> > 1.第一类丢失更新：A事务撤销时，把已经提交的B事务的更新数据覆盖了
> >
> > 2.第二类丢失更新：A事务提交时，把已经提交的B事务的更新数据覆盖了
> >
> > 3.脏读：A事务读到B事务里未提交更新的数据
> >
> > 4.不可重复读：A读到B未提交的某数据一次，后来B修改了又提交了，A再读，发现不一样
> >
> > 5.幻读：A读到B的数据时没发现这个数据，后来B增/删了这个数据，且提交了，A又读，发现数据个数都不一样了
>
> 通过事务的隔离级别来解决这些问题。隔离性分为四个级别：从宽到严：
>
> > 读未提交（Read Uncommitted）一个事务在执行过程中可以看到其他事务**没有提交的新插入**的记录，而且还能看到其他事务**没有提交的对已有记录的更新**。避免了 1
> >
> > 读已提交（Read Committed） 大多数数据库默认的隔离级别，一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且还能看到其他事务**已经提交**的**对已有记录的更新**。避免了1、3
> >
> > 可重复读（Repeatable-Read) MySQL所默认的级别，一个事务在执行过程中可以看到其他事务**已经提交**的**新插入**的记录，但是不能看到其他事务对已有记录的更新。避免了1、2、3、4
> >
> > 串行化（serializable）一个事务在执行过程中**完全看不到其他事务**对数据库所做的更新，当两个事务同时操作数据库中相同数据时，如果第一个事务已经在访问该数据，第二个事务只能停下来等待，必须等到第一个事务结束后才能恢复运行。避免了1、2、3、4、5
>
> 大多数关系数据库默认使用Read committed的隔离级别，Mysql InnoDB默认使用Read repeatable的隔离级别，这和Mysql replication 机制使用Statement日志格式有关。各数据库隔离级别的实现也是有差别的，例如Oracle支持Read committed 和Serializable两种隔离级别，另外可以通过使用读快照在Read committed级别上禁止不可重复读问题；MySQL默认采用RR隔离级别，SQL标准是要求RR解决不可重复读的问题，但是因为MySQL采用了gap lock，所以实际上MySQL的RR隔离级别也解决了幻读的问题，也就是Mysql InnoDB在Read repeatable级别上使用next-key locking 策略来避免幻读现象的产生。
>
> https://juejin.im/post/5b90cbf4e51d450e84776d27

**怎么实现事物的这些隔离级别**

> 主要方法有两种：加读写锁 || 使用一致性快照读，即MVCC（Multiversion Concurrency Control）。
>
> 具体的：

**MySQL锁机制**   [MySQL锁总结](https://zhuanlan.zhihu.com/p/29150809)

> 功能划分：共享锁与排他锁：共享锁（读锁）其他事务可以读，但不能写。排他锁（写锁） 其他事务不能读，也不能写。
>
> 粒度划分：MySQL 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：
>
> - MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）
> - BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁
> - InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。InnoDB 行锁是通过**给索引上的索引项加锁**来实现的，这种行锁实现特点意味着：只有**通过索引条件检索**数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！
>
> 默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。
>
> 不同粒度锁的比较：
>
> > 表级锁：开销小，加锁快，吃内存；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低，适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用。
> >
> > 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高，更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些OLTP系统。
> >
> > 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
> >
> >  锁冲突和死锁不是一个概念，锁冲突会按顺序执行，死锁是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。
>
> 特殊：InnoDB的间隙锁。当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给**符合条件的已有数据**记录的索引项**加锁**；对于键值**在条件范围内但并不存在**的记录，叫做“间隙（GAP)”，InnoDB也会**对这个“间隙”加锁**，这种锁机制就是所谓的间隙锁（Next-Key锁）。很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。**使用InnoDB间隙锁的目的**：**防止幻读**，以满足相关隔离级别的要求，**满足恢复和复制**的需要：MySQL 通过 binlog录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 binlog的恢复）有以下特点：
>
> 一是 MySQL 的恢复是 SQL 语句级的，也就是重新执行 binlog中的 SQL 语句。
>
> 二是 MySQL 的 binlog是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。
>
> 由此可见，MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。

**MySQL有哪些日志**

> 使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志(WAL)，修改数据需要写两次磁盘。如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。
>
> MySQL InnoDB中跟数据持久性、一致性有关的日志，有以下几种：
>
> - Bin Log: 是MySQL服务层产生的日志，常用来进行**数据恢复、数据库复制**，常见的MySQL主从架构，就是采用slave同步master的binlog实现的
> - Redo Log: 记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。
> - Undo Log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC

**MySQL多版本并发控制(MVCC)**  [MySQL InnoDB MVCC 机制的原理及实现](https://zhuanlan.zhihu.com/p/64576887)   [乐观锁和 MVCC 的区别](https://www.zhihu.com/question/27876575)  

[MySQL 技术内幕：事务隔离级别和MVCC](http://ningg.top/inside-mysql-transaction-and-mvcc/)

> 处理读写冲突的手段，目的在于提高数据库高并发场景下的吞吐性能。
>
> 1. `MySQL` 中 `InnoDB` 引擎支持 `MVCC`
> 2. 应对高并发事务, `MVCC` 比单纯的加行锁更有效, 开销更小
> 3. `MVCC` 在读已提交`（Read Committed）`和可重复读`（Repeatable Read）`隔离级别下起作用：为什么？在 `RU` 隔离级别下，直接读取版本的最新记录就 OK，对于 `SERIALIZABLE` 隔离级别，则是通过加锁互斥来访问数据，因此不需要 `MVCC` 的帮助
> 4. `MVCC` 既可以基于**乐观锁**又可以基于**悲观锁**来实现，和乐观锁的区别是，乐观锁解决的是读与读的冲突，mvcc解决的是读写冲突。



[MySQL索引总结](https://zhuanlan.zhihu.com/p/29118331)      [MySQL索引背后的数据结构及算法原理](https://blog.codinglabs.org/articles/theory-of-mysql-index.html)       [MySQL 索引原理及设计](https://icell.io/how-mysql-index-works/)

**MySQL索引原理**

> 为何使用B+树：硬盘访问速度慢、IO次数决定性能。磁盘预读性原理，B+树一个节点可以设置为一个页大小，降低io次数。
>
> B树每个节点可以有多个子树，M 阶 B 树表示该树每个节点最多有 M 个子树，每个**中间节点**有 k-1 个关键字（可以理解为数据）和 k 个子树（ k 介于阶数 M 和 M/2 之间，M/2 向上取整），所有叶子节点都在同一层，并且叶子节点只有关键字，指向孩子的指针为 null。
>
> B+树节点的子树数和关键字数相同（B 树是关键字数比子树数少一）；中间节点不包含实际数据，节点的关键字表示的是子树中的最大值，在子树中同样含有这个数据；所有数据都存放在叶子节点；叶子节点之间链表相连。
>
> B+树优点：
>
> 1. 层级更低，IO 次数更少
> 2. 每次都需要查询到叶子节点，查询性能稳定
> 3. 叶子节点形成有序链表，范围查询方便
>
> MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是**数据记录的地址**。
>
> ![img](assets/8.png)
>
> 虽然InnoDB也使用B+Tree作为索引结构，但第一个重大区别是InnoDB的数据文件本身就是索引文件。这棵树的叶节点data域保存了**完整的数据记录**。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主键索引。
>
> ![img](assets/10.png)

**聚簇索引与非聚簇索引的区别**

聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。

**InnoDB怎么实现聚簇索引**



**索引的分类**

> 从数据结构角度分：B+树索引、hash索引（只能等值查询）、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）、R-Tree索引（用于对GIS数据类型创建SPATIAL索引）
>
> 注意：fulltext索引用于**查找文本中的关键词**，而不是直接比较是否相等。查找条件使用 **MATCH AGAINST**，而不是普通的 WHERE。全文索引使用**倒排索引**实现，它记录着**关键词到其所在文档的映射**。
>
> 从物理存储角度分：聚簇索引、非聚簇索引，InndoDB中，聚簇索引的叶子节点存放了正行数据
>
> 从逻辑角度分：主键索引、普通索引、组合索引、唯一索引和非唯一索引

**索引的优缺点分析**

> 优点：
>
> - 索引大大减小了服务器需要扫描的数据量
> - 索引可以帮助服务器避免排序和临时表
> - 索引可以将随机IO变成顺序IO
> - 索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。
>
> 缺点：
>
> - 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。
> - 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。
> - 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
> - 对于非常小的表，大部分情况下简单的全表扫描更高效；

**MySQL索引优化**

> 

**何时需要使用索引？何时无需使用索引？**

> 何时使用索引：1. 对一个键码使用>, >=, =, <, <=, IF NULL和BETWEEN；2. 当使用不以通配符开始的LIKE模糊查询；3.在进行联结时从另一个表中提取行时；4. 找出指定索引的MAX()或MIN()值；5. 一个键码的前缀使用ORDER BY或GROUP BY
>
> 何时不使用索引：如果MySQL能估计出它将可能比扫描整张表还要快时，则不使用索引。比如只用了非聚簇索引不用聚簇索引，会先从非聚簇索引树上找到聚簇索引再去通过聚簇索引找，很慢。以及使用通配符开头的LIKE模糊查询、搜索一个索引而在另一个索引上做ORDER BY。

**MySQL有哪些表连接？**

> 交叉连接，内连接，外连接，自连接。
>
> 交叉连接A表m条，B表n条，那就会cross join出mn条。
>
> 内连接，加入A中有k条id和B中k条id是对应的，那A inner join B on A.id=B.id就只有k条记录，但如果不加这个相等条件，那inner join结果和cross join没啥不同。
>
> 左连接：A left join B，说明A在B左侧，以A为准，查出m条，与B相同主键的补齐、没有的列补null
>
> 右连接：A right join B，说明A在B右侧，以B为准，查出n条，与A相同主键的补齐，没有的补null

**MySQL主从同步**

> 1. slave服务器执行start slave，意味着开启主从复制开关。
> 2. 然后slave服务器开启io线程，请求连接master服务器、并请求从指定的binlog上的指定位置之后获取日志内容。（日志文件名和位置就是在配置主从复制任务时执行`change master`命令时指定的）
> 3. master服务器接受slave服务器的连接请求，并把slave请求的日志文件上某一位置之后的日志内容发送过去。此外，返回信息中还要此次返回binlog内容后，master服务器上新产生的binlog的文件名和开始位置点，好让下一次slave请求主从复制时，实则是从这次结束后的位置点开始复制。
> 4. slave服务器接收到了master发来的binlog内容，追加写回到自己的relay log中，并将新的 binlog 文件名和位置记录到 `master-info` 文件中，下次主从复制就能发回master获取新的更新复制了。
> 5. slave服务器的 SQL 线程实时地检测relay log中的追加更新，及时的把这些更新解析成SQL语句并执行，应用完毕后清理应用过的relay log。

**MySQL几大存储引擎区别**

> 主要区分MyISAM和InnoDB
>
> MyISAM：默认表级锁、不支持事务、支持fulltext索引、普通读写快、不适合于高并发大负载的场景
>
> InnoDB：默认行级锁，但是只是使用索引检索才用，否则变表级锁、支持事务、支持外键、支持mvcc、以前不支持fulltext但现在支持了，普通读写比MyISAM慢，但由于支持事务所以适合在高并发场景下用

https://www.cnblogs.com/rjzheng/p/9907304.html