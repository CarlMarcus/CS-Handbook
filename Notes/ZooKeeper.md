## ZooKeeper

1. zk可以干什么？

    统一配置管理、统一命名服务、分布式锁、集群管理

2. zk为什么可以做到？

    - ZooKeeper的数据结构，跟Unix文件系统非常类似，可以看做是一颗**树**，节点叫ZNode，节点有两种，临时的和持久的 Ephemeral/Persistent，分别还有顺序的普通的区别。与文件系统不同的是，这些节点**都可以设置关联的数据**，Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得Zookeeper**不能用于存放大量的数据**，每个节点的存放数据上限为**1M**。
    - 监听器：监听Znode节点的**数据变化**、监听子节点的**增减变化**。zk客户端向zk服务器注册watcher的同时，会将watcher对象存储在客户端的watchManager。Zk服务器触发watcher事件后，会向客户端发送通知，客户端线程从watchManager中回调watcher执行相应的功能。zk的getData()，getChildren()和exists()方法都可以注册watcher监听，如果没有监听，你就只能不断的轮询查看数据是否发生了改变，而监听则可以避免轮询带来的开销。zookeeper原生API注册Watcher需要反复注册，即Watcher触发之后就需要重新进行注册。
    - ACL权限控制

3. zk怎么做到的？

    - ABC三个主机的配置相似之处抽出来叫common放到zk节点上，三个主机监听(watch)这个ZNode，Znode数据有更新就会及时响应
    - 把需要统一命名的服务放到一个zk节点下，父节点就可以作为他们统一的名字
    - 在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode方法在locker下创建临时顺序节点，然后调用getChildren(“locker”)来获取locker下面的所有子节点，注意此时不用设置任何Watcher。客户端获取到所有的子节点path之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非locker所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到**比自己小的那个节点**，然后对其调用**exist()**方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。（公平锁实现）
    - 集群管理：被管理server在zk节点下创建临时节点，如果server与zk断联，临时节点将被删除，父节点的子节点将感知这一变化，知道有节点下线了。（选举：选id最小的顺序临时节点）

4. ZooKeeper是一个**分布式**的，开放源码的分布式**应用程序协调服务**，是Google的Chubby一个开源的实现，它是**集群的管理者**，**监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作**。客户端的**读请求**可以被集群中的**任意一台机器处理**，如果读请求在节点上注册了监听器，这个监听器也是由所连接的zookeeper机器来处理。对于**写请求**，这些请求会同**时发给其他zookeeper机器并且达成一致后，请求才会返回成功**。因此，随着**zookeeper的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降**。有序性是zookeeper中非常重要的一个特性，所有的**更新都是全局有序的**，每个更新都有一个**唯一的时间戳**，这个时间戳称为**zxid（Zookeeper Transaction Id）**。而**读请求只会相对于更新有序**，也就是读请求的返回结果中会带有这个**zookeeper最新的zxid**。

5. 1

6. 2

7. 3

8. 4

9. 5

10. 