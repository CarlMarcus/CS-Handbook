**排序**：基1全部实现

 

**数组**

\1.         小和问题，每一个数左边比当前数小的数累加起来。求小和。（利用归并的思想，逐步拆分，合并的时候统计算多少次小和）基1smallsum

\2.         打印所有逆序对（所有同样是归并的思想，合并的时候找到一组打印一组）

\3.         荷兰国旗问题（<num =num >num）基1

\4.         排序数组相邻两束最大插值maxGap（分桶思想，最大差值在不同桶之间）基1

\5.         用数组实现大小固定的栈和队列。基3

\6.         有序数组，长L的绳子最多覆盖多少个点（双指针）中上1

\7.         不同打包方式，一种a个一种b个，买n个最少打多少包？（最小公倍数或打表）中上1

\8.         牛牛染色，左右部分，最少染多少个？（从左数和从右数两个预处理数组）中上1

\9.         给定一个数组arr，求差值为k的去重数字对。（所有数存HashMap，遍历找差值k的）中上2

\10.     每次移动1个到相邻格子，使数组平均，最少移动多少。（见纸质笔记）中上3

\11.     数组arr和aim，任取arr数字能否加到aim。（二维dp[arr.len+1][aim+1]）基8

\12.     数组arr全为正，累加和为aim的最长子数组长度（双指针）进6

\13.     数组arr可正可负可0，累加和为aim的最长子数组长度（预处理数组0到i的sum，存hashmap，k sum，v index，从头开始，看sum+结尾处sum，最远能延伸多长）

\14.     数组arr可正可负可0，累加<=aim的最长子数组长度。（建min_sum和min_sum_index数组）进6

\15.     数组划分，左部分最大值和右部分最大值的差值最大值。（两个max必有一个是全局最大值，剩下半边的最大值绝对不会比端点值小，所以最好是另一半部分只有端点值）中上4

\16.     BFPRT 进1

\17.     最大值-最小值<num的子数组数量（双指针+窗口内最大值最小值更新结构）进视频2，02:05:45

\18.     最长递增子序列 进7、2019快手搭积木二分查找

\19.     最大m段子段和 2019快手善变的同伙

\20.     两个有序数组间相加和的TOP K问题 进8

\21.     子数组的最大累加和问题 进8 以每一位为子数组截止位置，dp[i] = dp[i-1]>0 ? dp[i-1]+arr[i] : arr[i]

\22.     整数数组arr，子数组最大异或和。进5代码，进视频7，maxeor

\23.     数组arr拆成最多的异或和为0的子数组个数。进4代码

 

**矩阵/****直方图**

\1.         N*N的01矩阵，返回边框全是1的最大正方形边长长度。（两个预处理矩阵，down：从每个点往下数有多少个连续的1；right：从每个点往右数有多少个连续的1）中上1

\2.         Zigzag打印矩阵 （打印斜线，布尔类型表示方向）中上2、基3

\3.         螺旋的方式打印矩阵 （分圈打印，每圈四步，往里缩圈）中上2、基3

\4.         有限空间顺时针90度转动矩阵 （分圈，每圈四个边都按遍历的方式依次交换）中上2、基3

\5.         为非负整数的二维数组matrix，每行和每列都是从小到大有序的。请判断aim是否在matrix中（从右上角开始找，aim大于当前点就下移，小于就右移）中上2、基3

\6.         数组值代表容器，可以装多少水。（每个位置上能有多少水->左和右最大值，两个预处理数组left和right，从左和从右端遍历到该位置时的最大值）中上4

\7.         岛问题，01矩阵中上下左右连成一片的1为岛，有几个岛。（每碰到一个1，就把其联通的1改成2，计数器+1，碰到2和0不管）基5，并行的做法用到并查集，基5

\8.         数组代表直方图，直方图内最大矩阵面积。（单调栈找每个高度左右最近比它小的，算h*s,更新最大值）进视频3-1，01:14:03

\9.         01矩阵内最大全1矩阵面积 （以第i行为底，往上数有多少连续1，变直方图，算最大值，按行遍历更新）进视频3-1，01:14:03

\10.     环形山峰（单调栈）进视频3-1，02:07:04

\11.     天际线 进2代码building outline

\12.     接雨水问题 leetcode 42 https://blog.csdn.net/whdAlive/article/details/81111507 遍历整个数组，找最高点；遍历整个数组，找最高点；遍历整个数组，找最高点

 

**栈/****对列**

\1.         一个额栈对栈进行升序排序。（这个栈只准降序放，不满足则往原栈倒）中上2

\2.         Get push 和getmin都是O1的栈。（每压一个data比较和min栈的栈顶，保证栈顶是当前data栈内最小）中上4

\3.         栈实现队列，队列实现栈。中上4

\4.         给你一个栈，请你逆序这个栈 基8

\5.         单调栈结构 实现 进视频3-1，00:48:13

 

**堆**

\1.         给定一个字符串类型的数组arr，求其中出现次数最多的前K个（HashMap记词频，建大小k的小根堆，遍历map往里推，最后剩的k个就是词频最大）中上3. 如果要实时的呢？纸质笔记

\2.         切金条，怎么最省。（哈夫曼问题，丢小根堆，每次取最小两个，相加放回，直到剩1个）基7

\3.         最大收益问题 基7（costs值小根堆，弹小于启动资金m的，弹出值按profits建大根堆，弹堆顶，加到m上，循环k次）

\4.         一个数据流中， 随时可以取得中位数 基7

 

**字符串**

\1.         前缀树：基7

\2.         arr2中有哪些字符，是arr1中出现的，arr2中有哪些字符，是作为arr1中某个字符串前缀出现的（利用前缀树）基7

\3.         字符串数组的拼接得到最低字典序（重写comparator，a+b小于b+a则a在前，对整个组排序，完事从头加到尾）基7

\4.         KMP和应用，进1

\5.         Manacher最长回文子串长度 进1

\6.         最长回文子序列 2019快手 回文字符串

\7.         字符串括号有效性检验。（左括号+1，右括号-1，不允许非法值）中上1

\8.         将给定的数转换为字符串，26-Z。（chs[0]+F(chs[1,len])和chs[0，1]+ F(chs[2,len]) 可递归,dp）中上2

\9.         判断是否互为旋转字符串。（先判str1和str2长度是不是相等，再用kmp判str2是不是str1+str1的子串）中上4

\10.     字符串四则运算公式，进4

\11.     字符串匹配问题 进6

\12.     最长公共子序列问题 进7

\13.     最长公共子串问题 进7

\14.     字符串分割，分的每一部分回文，最少分割多少次 进7

\15.     字符串的交错组成 进7  str1="AB"， str2="12 变 A1B2, A12B都对

\16.     找到字符串的最长无重复字符子串 进8

 

**树**

\1.         二叉树的先序、 中序、 后序遍历，递归非递归 基4

\2.         直观的打印一颗二叉树 基4

\3.         在二叉树中找到一个节点的后继节点（中序遍历的下一个节点）基4

\4.         二叉树的序列化和反序列化 基4

\5.         判断一棵二叉树是否是平衡二叉树 基4

\6.         是否是搜索二叉树、是否是完全二叉树 基4

\7.         已知一棵完全二叉树， 求其节点的个数 基4

\8.         打印一个字符串的全部子序列，包括空字符串 （dp）基8

\9.         打印一个字符串全部的排列 基8 不重复 基8

\10.     二叉树 Morris遍历 进3代码实现

\11.     给定一个非负整数n，代表二叉树的节点个数。返回能形成多少种不同的二叉树结构（套路）中上1

\12.     带权二叉树从根到叶所有路径中最大的权值和。（递归套路）中上2

 

**链表**

\1.         反转单向和双向链表 基3

\2.         打印两个有序链表的公共部分 基3

\3.         判断一个链表是否为回文结构 基3

\4.         将单向链表按某值划分成左边小、 中间相等、 右边大的形式 基3

\5.         复制含有随机指针节点的链表 基3

\6.         两个单链表相交的一系列问题 基3

\7.         设计LRU，进4

\8.         约瑟夫环 进6

 

**概率**

\1.         给定一个函数f，以p概率返回0，以1-p概率返回1。请加工出等概率返回0和1的函数g。（roll两次，00重做，01范围0，10返回1，11重做）中上1

 

**博弈问题**：

\1.         N个箱子，每次必须拿4的次幂个，1 4 16等，先后手，最后拿完的赢。（打表）中上2

\2.         纸牌博弈，每次取最左最右，总和大的赢。（DP）进6

 

**动态规划**

\1.         正数二维数组，从左上到右下角，路径和最小的值是多少。中上4

\2.         母牛生小牛，三岁以上的小牛可以生，牛只能活十岁。F(n)=f(n-1)+f(n-3)-f(n-10)

\3.         01背包 基8

\4.         换钱方式 进6

 

**图**

\1.         BFS/DFS 基6

\2.         拓扑排序（循环移出入度为0的节点，按移出的顺序排序） 基6

\3.         Kruskal/prim算法，找最小生成树的（带权路径和最小）基6

\4.         Dijkstra算法 图中某点到其余所有点最短路径 基6