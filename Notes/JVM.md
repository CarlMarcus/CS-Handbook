## JVM

[SnailClimb/JavaGuide/JVM内存模型](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java内存区域.md)

JVM内存模型分为五个部分：程序技术器PC、Java虚拟机栈、本地方法栈、堆、方法区。

PC：记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。

JVM stack：每个 Java 方法在执行的同时会创建一个栈帧用于存储**局部变量表**、**操作数栈**、**常量池引用**等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

`java -Xss2M ` 指定每个线程的 Java 虚拟机栈内存大小为2M。该区域可能抛出以下异常：

- 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；（个数限制）
- 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。（内存限制）

本地方法栈：与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。一般由C/C++/汇编写

堆：大部分对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）。根据分代收集算法将堆分为新生代和老年代。堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。`java -Xms1M -Xmx2M` 指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。

方法区：用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。

![img](assets/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564de8bf90e8a18ce697b6e695b0e68daee58cbae59f9f2e706e67.png)

![img](assets/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d334a617661e8bf90e8a18ce697b6e695b0e68daee58cbae59f9f4a444b312e382e706e67-1567404571643.png) 