# Java并发

**同步异步、阻塞非阻塞？**[怎样理解阻塞非阻塞与同步异步的区别](https://www.zhihu.com/question/19732473)

简单地说，同步与非同步是针对消息应答来说，阻塞与非阻塞是针对调用者状态来说。	如果调用者发出调用后，在没有得到结果之前，该调用就不返回，而是需要调用者轮询，那就是同步；而不论有没有完成调用，调用者发出调用后都立即返回（虽然没有结果），应答者过一段时间完成调用后发出一个信号（比如回调函数）通知调用者完成了调用，则是异步。	而阻塞与非阻塞是说，调用者在等待调用结果的时间里，是挂起不干事还是去干别的事。同步可以非阻塞也可以阻塞，异步可以非阻塞也可以阻塞，常见的是同步阻塞与异步非阻塞。

**临界资源**：临界资源是指每次仅允许一个进程访问的资源。各进程采取互斥的方式，实现共享的资源称作临界资源。硬件有打印机、磁带机等,软件有消息缓冲队列、变量、数组、缓冲区等。**临界区**：每个进程中访问临界资源的那段代码称为临界区，每次只允许一个进程进入临界区，进入后，不允许其他进程进入。

**如何创建新线程？**继承thread类、实现Runnable接口、实现Callable接口、**从线程池中创建**

<u>继承Thread类</u>：注意区分线程运行的区别：run & start，run是真开始跑，start是使线程就绪、需要得到cpu时间片才能跑

<u>实现Runnable接口</u>：实现Runnable接口，重写run方法，创建实现类实例，将实例用Thread包装再start；

<u>实现Callable接口</u>：创建Callable接口的实现类，并重写call()方法，该call()方法将作为线程执行体，并且有返回值；创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值；使用FutureTask对象作为Thread对象的target创建并启动新线程；调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。！！！

对比：

> - 使用Runnable & Callable接口：线程类只是实现了接口，还可以继承其他类。在这种方式下，多个线程可以共享**同一个target对象**，所以非常适合多个相同线程来处理**同一份资源**的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。编程稍微复杂，如果要访问当前线程，则必须使用`Thread.currentThread()`方法。
> - 继承Thread类：编写简单，如果需要访问当前线程，则无需使用`Thread.currentThread()`方法，直接使用this即可获得当前线程。劣势是：线程类已经继承了Thread类，所以不能再继承其他父类。

**通过线程池创建线程** [如何优雅的使用和理解线程池](https://segmentfault.com/a/1190000015808897)

> 《阿里巴巴Java手册》有一条：线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致内存耗尽或过度切换的问题。

JDK5引入Excutor框架

