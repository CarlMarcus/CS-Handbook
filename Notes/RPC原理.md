## RPC

概念：远程过程调用（Remote Procedu Call），比如两台服务器A和B，一个应用部署在服务器A上，想要调用放在服务器B上的某应用提供的函数、方法等，由于不在同一个内存空间，不能直接调用，需要通过网络通讯来表达调用的语义和传递调用的数据。

- RMI——Remote Method Invoke：调用远程的方法。“方法”一般是附属于某个对象上的，所以通常RMI指对在远程的计算机上的某个**对象**，进行其方法函数的调用。
- RPC——Remote Procedure Call：远程过程调用。指的是对网络上另外一个计算机上的，某段特定的**函数代码**的调用。

RPC框架包含**四**个部分：

> - 通信模型（网络通信框架）：假设通信的为A机器与B机器，A与B之间有通信模型，在Java中一般基于BIO或NIO，一般用Netty框架；
> - 过程（服务）定位：使用给定的通信方式（TCP或HTTP），与确定IP与端口及方法名称确定具体的过程或方法；
>
> - 远程代理对象：本地调用的方法(服务)其实是远程方法的本地代理，因此可能需要一个远程代理对象，对于Java而言，远程代理对象可以使用Java的动态对象实现，封装了调用远程方法调用；
> - 序列化协议，将对象名称、方法名称、参数等对象信息进行网络传输需要转换成二进制传输，这里可能需要不同的序列化技术方案。如protobuf，Arvo等。

**设计基本要素：**

**Call - ID 映射**：在本地过程调用时，函数体是直接通过**函数指针**来指定的，因为在同一个物理机上，有相同的内存空间。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是**完全不一样**的。在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是**唯一确定**的。客户端在做远程过程调用时，必须附上这个ID。服务器和客户端还要分别维护一个Call - ID映射表（可以用HashMap）。两者的表不一定需要完全相同，但**相同的函数对应的Call ID必须相同**。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。

**序列化和反序列化**：客户端怎么把参数值传给远程的函数呢？本地过程调用中是把参数压栈，但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言。需要客户端把参数先**转成一个字节流**，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。序列化和反序列化的实现可以使用**Protobuf**或者**FlatBuffers**之类的。

**网络传输**：所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的**参数字节流**传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。

​	当然，这里面还有一些细节可以填充，比如如何**处理网络错误**，如何**防止攻击**，如何做**流量控制**，等等。但有了以上的架构，这些都可以持续加进去。除了网络通信，RPC还需要有比较高效的序列化框架，以及一种寻址方式。如果是带会话（状态）的RPC调用，还需要有会话和状态保持的功能。

过程：

1. ```
    // Client端 
    //    int l_times_r = Call(ServerAddr, Multiply, lvalue, rvalue)
    1. 将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法
    2. 将Call ID，lvalue和rvalue序列化。可以直接将它们的值以二进制形式打包
    3. 把2中得到的数据包发送给ServerAddrress，这需要使用网络传输层
    4. 等待服务器返回结果
    5. 如果服务器调用成功，那么就将结果反序列化，并赋给l_times_r
    
    // Server端
    1. 在本地维护一个Call ID到函数指针的映射call_id_map，可以用HashMap
    2. 等待请求
    3. 得到一个请求后，将其数据包反序列化，得到Call ID
    4. 通过在call_id_map中查找，得到相应的函数指针
    5. 将lvalue和rvalue反序列化后得到本地参数值，在本地调用Multiply函数，得到结果
    6. 将结果序列化后通过网络返回给Client
    ```

远程调用的优势有：

> - 屏蔽了网络层。因此在传输协议和编码协议上，我们可以选择不同的方案。比如WebService方案就是用的HTTP传输协议+SOAP编码协议；而REST的方案往往使用HTTP+JSON协议。Facebook的Thrift甚至可以定制任何不同的传输协议和编码协议，你可以用TCP+Google Protocol Buffer，也可以用UDP+JSON……。由于屏蔽了网络层，你可以根据实际需要来独立的优化网络部分，而无需涉及业务逻辑的处理代码，这对于需要在各种网络环境下运行的程序来说，非常有价值。
> - 函数映射协议。你可以直接用编程语言来书写数据结构和函数定义，取代编写大量的编码协议格式和分包处理逻辑。对于那些业务逻辑非常复杂的系统，比如网络游戏，可以节省大量定义消息格式的时间。而且函数调用模型非常容易学习，不需要学习通信协议和流程，让经验较浅的程序员也能很容易的开始使用网络编程。

远程调用的缺点：

> - 增加了性能消耗。由于把网络通信包装成“函数”，需要大量额外的处理。比如需要预生产代码，或者使用反射机制。这些都是额外消耗CPU和内存的操作。而且为了表达复杂的数据类型，比如变长的类型string/map/list，这些都要数据包中增加更多的描述性信息，则会占用更多的网络包长度。
> - 不必要的复杂化。如果你仅仅是为了某些特定的业务需求，比如传送一个固定的文件，那么你应该用HTTP/FTP协议模型。如果为了做监控或者IM软件，用简单的消息编码收发会更快速高效。如果是为了做代理服务器，用流式的处理会很简单。另外，如果你要做数据广播，那么消息队列会很容易做到，而远程调用这几乎无法完成。

主流RPC框架性能对比：https://colobu.com/2016/09/05/benchmarks-of-popular-rpc-frameworks/

RPC的前世今生：

[WebSerivce的学习](https://alanli7991.github.io/2016/03/03/WebSerivce%E7%9A%84%E5%AD%A6%E4%B9%A0/)

[RPC/Netty/Dubbo的大致概念](https://alanli7991.github.io/2016/03/06/RPCNettyDubbo%E7%9A%84%E5%A4%A7%E8%87%B4%E6%A6%82%E5%BF%B5/)

