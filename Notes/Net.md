## Net面试资料

**OSI七层模型**：物理层Ethernet、数据链路层ARP协议、网络层IP、传输层TCP/UDP、会话层RPC、表示层、应用层。

**传输层多路复用和分用**：将运输层报文段中的数据交付到正确的套接字的工作称为多路分解(demultiplexing),在源主机当中从不同的套接字中收集数据块，并为每一个数据块封装上首部信息(用于分解)从而生成报文段，然后将此报文段传递到网络层。所有的这些工作称为多路复用(multiplexing)。https://www.cnblogs.com/hithongming/p/9379397.html

**传输层和网络层的区别**：网络层负责ip数据报的产生以及ip数据包在逻辑网络上的路由转发，寻址是主机级别的。传输层提供端到端通信服务层次,提供可靠及非可靠连接，寻址是进程级的。网络层负责分组、路由和转发；传输层负责端口寻址、差错控制、拥塞控制等。https://blog.csdn.net/jinzhao1993/article/details/53354086

IP

**UDP协议的特点**：无连接、面向报文、单播多播广播、头部开销小、无差错恢复拥塞控制、到达目的地是无序的、不可靠、但是速度快。https://cloud.tencent.com/developer/article/1405940 https://jaminzhang.github.io/network/The-Difference-Between-TCP-And-UDP-Protocol/

**UDP协议格式**：16位源端口、16位目的端口、16位报文长度、16位校验和，总共8字节的首部，外加数据。

**TCP协议的特点**：面向连接、面向字节流、只能点对点、头部长20个字节、可以进行差错恢复和拥塞控制、到达目的后会对乱序的包重排序、可靠交付、比较慢。

**TCP协议格式**：16位源端口、16位目的端口、32位序列号(SEQ)、32位确认序号(ACK)、数据偏移(4位)|保留(6位)|六个状态位(URG\ACK\PSH\RST\SYN\FIN)、16位窗口大小、16位校验和、16位紧急指针、32位选项和填充

![preview](assets/v2-8f5725f163d7f6390a75f3a2d337bc1c_r.jpg)

**TCP三次握手**：请求建立时SYN=1,ACK=0；回应建立是SYN=1,ACK=1; 正式建立时SYN=0,ACK=1。client和server的seq每个回合后加1，回应的ack是它收到的seq+1，所以回应建立的ack和client正式建立的seq是一样的。

![img](assets/20170104214009596.png)

**TCP四次挥手**：**中断连接端可以是Client端，也可以是Server端。**

![img](assets/1641067-5ed8bf6c24244b4c.webp)

**为什么连接的时候是三次握手，关闭的时候却是四次握手？**

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

**为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。这时当server端超过2MSL没收到ACK就会超时重传FIN，经过一1个MSL到达client端，这时client刚好等待2MSL，可以防止ACK报文丢失。另外 

1.如果关闭了，ACK又丢失了，server会重发FIN，但是一直接收不到ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。

2.如果Client直接CLOSED，然后又再向Server发起一个新连接，新连接与刚关闭的连接的端口号有可能是相同的。假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。

**TCP协议的可靠传输如何保证**

1.确认和重传机制。2.TCP报文头部校验和，用于检验报文是否损坏。3.数据的合理分片和排序。tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。4.流量控制。5.拥塞控制。6.停止等待协议。指发送完一个分组就停止发送,等待对方的确认,只有对方确认过,才发送下一个分组。

**连续等待协议、连续ARQ协议、回退n帧协议和滑动窗口协议** https://blog.csdn.net/yangbodong22011/article/details/48473183       https://sexywp.com/introduction-of-arq.htm       https://www.jianshu.com/p/07bd39becbfd

> 停止等待 就是指发送完一个分组就停止发送，等待对方的确认，只有对方确认过，才发送下一个分组。
>
> 连续ARQ协议：当发送站点发送完一个数据帧后，不是停下来等待应答帧，而是可以**连续再发送若干个数据帧**。如果在此过程中又收到了接收端发来的应答帧，那么还可以接着发送数据帧。由于减少了等待时间，整个通信的吞吐量就提高了。
>
> 回退n帧协议：在后退N帧式ARQ中，发送方不需要在收到上一帧的ACK后才能开始发送下一帧，而是**可以连续发送帧**。当接受方检测出失序的信息帧后，要求发送方重发最后一个正确接受的信息帧之后的所有未确认的帧；或者当发送方发送了N个帧后，若发现该N个帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不又重传该出错帧及随后的N个帧。**换句话说，接受帧只允许按顺序接受帧。**
>
> 滑动窗口的一个特点：**接收方通过告知发送方自己的窗口大小**，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。
>
> 对ACK的再认识，ack通常被理解为收到数据后给出的一个确认ACK，ACK包含两个非常重要的信息：
> **一是期望接收到的下一字节的序号n**，该n代表接收方已经接收到了前n-1字节数据，此时如果接收方收到第n+1字节数据而不是第n字节数据，接收方是不会发送序号为n+2的ACK的。举个例子，假如接收端收到1-1024字节，它会发送一个确认号为1025的ACK,但是接下来收到的是2049-3072，它是不会发送确认号为3072的ACK,而依旧发送1025的ACK。
>
> **二是当前的窗口大小m，如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，假定当前发送方已发送到第x字节，则可以发送的字节数就是y=m-(x-n).这就是滑动窗口控制流量的基本原理**
>
> **重点：发送方根据收到ACK当中的期望收到的下一个字节的序号n以及窗口m，还有当前已经发送的字节序号x，算出还可以发送的字节数。**

**TCP的流量控制和拥塞控制**   https://zhuanlan.zhihu.com/p/37379780

> 流量控制：利用滑动窗口协议实现，滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。
>
> 拥塞控制：（ 1 ）慢开始，从1开始翻倍、拥塞避免，让拥塞窗口缓慢增长，每次+1（ 2 ）快重传，要求接收方在收到一个失序的报文段后就立即发出重复确认、快恢复，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。

**HTTP工作流程：**

> 1.地址解析：协议类型、主机名，走DNS，先问本地host，再查局域网dns，一个个层级往上、端口号、请求文件名：如index.html、请求参数：如?name=tom&age=18
>
> 2.封装HTTP请求
>
> 3.封装TCP包，然后三次握手建立连接  4.客户端正式发送请求命令 5.服务端响应 6.客户端解析http响应包 7.过了Connection-alive后关闭连接

 HTTP请求格式：

